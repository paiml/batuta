# Oracle Mode

> **"Ask the Oracle, receive the wisdom of the stack."**

Oracle Mode is the intelligent query interface for the Sovereign AI Stack. Instead of manually researching which components to use, Oracle Mode guides you to the optimal solution based on your requirements.

## Overview

Oracle Mode provides:

- **Knowledge Graph:** Complete registry of stack components with capabilities
- **Natural Language Interface:** Query in plain English
- **Intelligent Recommendations:** Algorithm and backend selection
- **Code Generation:** Ready-to-use examples

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     ORACLE MODE ARCHITECTURE                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  Natural Query  â”‚
                    â”‚   "Train RF"    â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       QUERY ENGINE                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   Domain    â”‚   â”‚  Algorithm   â”‚   â”‚   Performance        â”‚ â”‚
â”‚  â”‚  Detection  â”‚   â”‚  Extraction  â”‚   â”‚   Hints              â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     KNOWLEDGE GRAPH                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Layer 0: Primitives   â†’ trueno, trueno-db, trueno-graph   â”‚  â”‚
â”‚  â”‚ Layer 1: ML           â†’ aprender                          â”‚  â”‚
â”‚  â”‚ Layer 2: Pipeline     â†’ entrenar, realizar                â”‚  â”‚
â”‚  â”‚ Layer 3: Transpilers  â†’ depyler, decy, bashrs, ruchy      â”‚  â”‚
â”‚  â”‚ Layer 4: Orchestrationâ†’ batuta, repartir                  â”‚  â”‚
â”‚  â”‚ Layer 5: Quality      â†’ certeza, pmat, renacer            â”‚  â”‚
â”‚  â”‚ Layer 6: Data         â†’ alimentar                         â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      RECOMMENDER                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Component  â”‚   â”‚   Backend    â”‚   â”‚   Distribution       â”‚ â”‚
â”‚  â”‚  Selection  â”‚   â”‚   Selection  â”‚   â”‚   Decision           â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â†“
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚    Response     â”‚
                    â”‚  + Code Example â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## The Sovereign AI Stack

Oracle Mode knows all 20 components in the stack:

| Layer | Components | Purpose |
|-------|------------|---------|
| **L0: Primitives** | trueno, trueno-db, trueno-graph, trueno-viz, trueno-rag | SIMD/GPU compute, vector storage, graph ops, RAG |
| **L1: ML** | aprender | First-principles ML algorithms |
| **L2: Pipeline** | entrenar, realizar | Training loops, inference runtime |
| **L3: Transpilers** | depyler, decy, bashrs, ruchy | Python/C transpilers + Rustâ†”Shell bidirectional |
| **L4: Orchestration** | batuta, repartir, pforge | Migration workflow, distributed compute, MCP servers |
| **L5: Quality** | certeza, pmat, renacer | Testing, profiling, syscall tracing |
| **L6: Data** | alimentar, pacha | Data loading, model/recipe registry |

## Basic Usage

### CLI Interface

```bash
# List all stack components
$ batuta oracle --list

# Show component details
$ batuta oracle --show trueno

# Find components by capability
$ batuta oracle --capabilities simd

# Query integration patterns
$ batuta oracle --integrate aprender realizar

# Interactive mode
$ batuta oracle --interactive
```

### Interactive Mode

```bash
$ batuta oracle --interactive

ðŸ”® Oracle Mode - Ask anything about the Sovereign AI Stack

oracle> How do I train a random forest on 1M samples?

ðŸ“Š Analysis:
  Problem class: Supervised Learning
  Algorithm: random_forest
  Data size: Large (1M samples)

ðŸ’¡ Primary Recommendation: aprender
   Path: aprender::tree::RandomForest
   Confidence: 95%
   Rationale: Random forest is ideal for large tabular datasets

ðŸ”§ Backend: SIMD
   Rationale: SIMD vectorization optimal for 1M samples with High complexity

ðŸ“¦ Supporting Components:
   - trueno (95%): SIMD-accelerated tensor operations
   - alimentar (70%): Parallel data loading

ðŸ’» Code Example:
use aprender::tree::RandomForest;
use alimentar::Dataset;

let dataset = Dataset::from_csv("data.csv")?;
let (x, y) = dataset.split_features_target("label")?;

let model = RandomForest::new()
    .n_estimators(100)
    .max_depth(Some(10))
    .n_jobs(-1)  // Use all cores
    .fit(&x, &y)?;

ðŸ“š Related Queries:
   - How to optimize random forest hyperparameters?
   - How to serialize trained models with realizar?
   - How to distribute training with repartir?
```

## Backend Selection

Oracle Mode uses **Amdahl's Law** and **PCIe transfer overhead** (Gregg & Hazelwood, 2011) to select the optimal compute backend.

### The 5Ã— Rule

GPU dispatch is only beneficial when compute time exceeds 5Ã— the PCIe transfer time:

```
If compute_time > 5 Ã— transfer_time â†’ Use GPU
Otherwise â†’ Use SIMD
```

### Backend Decision Matrix

| Operation | Complexity | Small Data | Large Data | GPU Available |
|-----------|------------|------------|------------|---------------|
| Element-wise | O(n) | Scalar | SIMD | SIMD (memory-bound) |
| Reductions | O(n) | Scalar | SIMD | SIMD |
| Matrix mult | O(nÂ³) | SIMD | GPU | GPU |
| Conv2D | O(nÂ²kÂ²) | SIMD | GPU | GPU |
| Attention | O(nÂ²d) | SIMD | GPU | GPU |

### Backend Selection Example

```bash
oracle> What backend for 2048Ã—2048 matrix multiplication?

ðŸŽ¯ Backend Selection:
  Operation: Matrix multiplication
  Size: 2048 Ã— 2048 = 4.2M elements
  Complexity: O(nÂ³) = 8.6B FLOPs

  PCIe Transfer: 4.2M Ã— 4 bytes Ã— 2 = 34 MB
  Transfer time: 34 MB / 32 GB/s = 1.06 ms
  Compute time: 8.6B FLOPs / 20 TFLOPS = 0.43 ms

  Ratio: 0.43 / 1.06 = 0.41Ã— (< 5Ã—)

ðŸ’¡ Recommendation: SIMD
   Rationale: PCIe overhead dominates. Use trueno SIMD backend.
   GPU becomes beneficial at ~8192Ã—8192.
```

## Distribution Decision

Oracle uses **Amdahl's Law** for distribution decisions:

```
Speedup = 1 / ((1 - P) + P/N)

Where:
  P = Parallel fraction of workload
  N = Number of nodes
```

### Distribution Example

```bash
oracle> Should I distribute random forest on 4 nodes?

ðŸ“Š Amdahl's Law Analysis:
  Algorithm: Random Forest
  Parallel fraction: 0.95 (tree training is parallelizable)
  Nodes: 4

  Theoretical speedup: 1 / (0.05 + 0.95/4) = 3.48Ã—
  Communication overhead: ~10% per node = 40%
  Effective speedup: 3.48 Ã— 0.6 = 2.09Ã—

ðŸ’¡ Recommendation: Yes, distribute with repartir
   Expected speedup: 2.09Ã—
   Break-even: 2+ nodes

ðŸ“¦ Code Example:
use repartir::{Executor, WorkStealing};
use aprender::tree::RandomForest;

let executor = Executor::new()
    .with_workers(4)
    .with_scheduler(WorkStealing);

let forest = executor.map(
    trees.chunks(25),
    |chunk| train_tree_subset(chunk, &data)
).await?;
```

## Knowledge Graph Queries

### Find by Capability

```bash
oracle> What components support GPU?

ðŸ” Components with GPU capability:
  - trueno: SIMD-accelerated tensor operations with GPU dispatch
  - realizar: GPU-accelerated inference runtime
```

### Find by Domain

```bash
oracle> What do I need for graph analytics?

ðŸ§  Graph Analytics Components:
  - trueno-graph: Graph traversal and algorithms
  - trueno-db: Vector storage with graph indexes
```

### Integration Patterns

```bash
oracle> How do I integrate depyler with aprender?

ðŸ”— Integration: depyler â†’ aprender

Pattern: sklearn_migration
Description: Convert sklearn code to aprender

Example:
# Original Python (sklearn)
from sklearn.ensemble import RandomForestClassifier
model = RandomForestClassifier(n_estimators=100)
model.fit(X, y)

# After depyler transpilation
use aprender::tree::RandomForest;
let model = RandomForest::new()
    .n_estimators(100)
    .fit(&x, &y)?;
```

## Academic Foundations

Oracle Mode is grounded in peer-reviewed research:

| Concept | Reference | Application |
|---------|-----------|-------------|
| PCIe overhead | Gregg & Hazelwood (2011) | Backend selection |
| Amdahl's Law | Amdahl (1967) | Distribution decisions |
| Roofline model | Williams et al. (2009) | Performance bounds |
| SIMD vectorization | Fog (2022) | Optimization hints |
| Decision trees | Breiman (2001) | Algorithm recommendations |

## JSON Output

For programmatic access, use `--format json`:

```bash
$ batuta oracle --format json "random forest large data"
```

```json
{
  "problem_class": "Supervised Learning",
  "algorithm": "random_forest",
  "primary": {
    "component": "aprender",
    "path": "aprender::tree::RandomForest",
    "confidence": 0.95,
    "rationale": "Random forest is ideal for large tabular datasets"
  },
  "supporting": [
    {
      "component": "trueno",
      "confidence": 0.95,
      "rationale": "SIMD-accelerated tensor operations"
    }
  ],
  "compute": {
    "backend": "SIMD",
    "rationale": "SIMD vectorization optimal for large datasets"
  },
  "distribution": {
    "needed": false,
    "rationale": "Single-node sufficient for this workload size"
  },
  "code_example": "use aprender::tree::RandomForest;..."
}
```

## Programmatic API

Use Oracle Mode from Rust code:

```rust
use batuta::oracle::{Recommender, OracleQuery, DataSize};

// Natural language query
let recommender = Recommender::new();
let response = recommender.query("train random forest on 1M samples");

println!("Primary: {}", response.primary.component);
println!("Backend: {:?}", response.compute.backend);

// Structured query with constraints
let query = OracleQuery::new("neural network training")
    .with_data_size(DataSize::samples(1_000_000))
    .with_hardware(HardwareSpec::with_gpu(16.0))
    .sovereign_only();

let response = recommender.query_structured(&query);

if response.distribution.needed {
    println!("Distribute with: {:?}", response.distribution.tool);
}
```

## Key Takeaways

- **Query naturally:** Ask in plain English, get precise answers
- **Trust the math:** Backend selection based on PCIe and Amdahl analysis
- **Complete stack:** All 20 components indexed with capabilities
- **Code ready:** Get working examples, not just recommendations
- **Reproducible:** JSON output for automation and CI/CD

## Next Steps

Try Oracle Mode yourself:

```bash
# Run the demo
cargo run --example oracle_demo

# Start interactive mode
batuta oracle --interactive

# Query from CLI
batuta oracle "How do I migrate sklearn to Rust?"
```

---

**Previous:** [Renacer: Syscall Tracing](./renacer.md)
**Next:** [Example Overview](../part4/example-overview.md)
